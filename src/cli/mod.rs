//! CLI module for command-line interface.

pub mod handlers;
pub mod interactive;
pub mod table;

use clap::{Parser, Subcommand};

/// ATS Resume Checker CLI.
#[derive(Parser, Debug)]
#[command(name = "ats-checker")]
#[command(version)]
#[command(
    about = "ATS Resume Checker - Enhance resumes using AI and score them against job descriptions"
)]
#[command(
    long_about = "ATS Resume Checker is a powerful tool that uses AI to enhance resumes and score them \
    against job descriptions. It supports multiple formats (TXT, PDF, DOCX), provides detailed \
    scoring across multiple categories, and can iteratively improve resumes to reach target scores.\n\n\
    Run without arguments to start interactive mode, or use subcommands for specific operations."
)]
#[command(after_help = "EXAMPLES:\n  \
    # Interactive mode\n  \
    ats-checker\n\n  \
    # Score a resume\n  \
    ats-checker score-resume --resume output/john_doe.json\n\n  \
    # Score resume-job match\n  \
    ats-checker score-match --resume output/resume.json --job jobs/software_engineer.txt\n\n  \
    # Rank jobs by score\n  \
    ats-checker rank-jobs --results workspace/search_results.toml --top 10\n\n\
    For more information, visit: https://github.com/your-repo/ats-checker")]
pub struct Cli {
    /// Path to configuration file
    #[arg(short, long, default_value = "config/config.toml")]
    #[arg(help = "Path to TOML configuration file")]
    #[arg(
        long_help = "Path to the TOML configuration file containing API keys, paths, and processing settings.\n\
        See config/config.toml for an example."
    )]
    pub config: String,

    /// Enable verbose output
    #[arg(short, long, global = true)]
    #[arg(help = "Show detailed information during execution")]
    pub verbose: bool,

    /// Enable quiet mode (minimal output)
    #[arg(short, long, global = true)]
    #[arg(help = "Suppress all non-essential output")]
    pub quiet: bool,

    /// Subcommand to run
    #[command(subcommand)]
    pub command: Option<Commands>,
}

/// Available commands.
#[derive(Subcommand, Debug)]
pub enum Commands {
    /// Interactive menu mode (default).
    Interactive,

    /// Score a resume file
    #[command(name = "score-resume")]
    #[command(about = "Calculate quality score for a resume")]
    #[command(
        long_about = "Analyzes a resume file and calculates a comprehensive quality score based on \
        completeness, skills quality, experience quality, and impact. Scores range from 0-100 with \
        detailed breakdowns by category."
    )]
    #[command(after_help = "EXAMPLE:\n  \
        ats-checker score-resume --resume output/john_doe.json --weights config/scoring_weights.toml")]
    ScoreResume {
        /// Path to the resume file (JSON or TOML format)
        #[arg(long)]
        #[arg(help = "Path to AI-enhanced resume file")]
        #[arg(
            long_help = "Path to the resume file in JSON or TOML format. This should be an \
            AI-enhanced resume generated by the tool, not a raw resume file."
        )]
        resume: String,

        /// Path to scoring weights configuration (optional)
        #[arg(long)]
        #[arg(help = "Custom scoring weights file")]
        #[arg(
            long_help = "Optional path to a TOML file with custom scoring weights. \
            If not provided, uses the weights specified in the main config file."
        )]
        weights: Option<String>,
    },

    /// Score resume-job compatibility
    #[command(name = "score-match")]
    #[command(about = "Calculate how well a resume matches a job description")]
    #[command(
        long_about = "Analyzes the compatibility between a resume and a job description. \
        Provides detailed scores for keyword overlap, skills match, and role alignment. \
        Also calculates overall resume quality and provides a combined match score."
    )]
    #[command(after_help = "EXAMPLE:\n  \
        ats-checker score-match --resume output/resume.json --job jobs/senior_engineer.txt")]
    ScoreMatch {
        /// Path to the resume file (JSON or TOML format)
        #[arg(long)]
        #[arg(help = "Path to AI-enhanced resume file")]
        resume: String,

        /// Path to the job description file
        #[arg(long)]
        #[arg(help = "Path to job description file (any text format)")]
        #[arg(
            long_help = "Path to the job description file. Can be TXT, MD, or any text-based format. \
            The file should contain the complete job posting."
        )]
        job: String,

        /// Path to scoring weights configuration (optional)
        #[arg(long)]
        #[arg(help = "Custom scoring weights file")]
        weights: Option<String>,
    },

    /// Rank and display job postings by score
    #[command(name = "rank-jobs")]
    #[command(about = "Rank jobs from a search results file by quality score")]
    #[command(
        long_about = "Analyzes job postings from a search results file and ranks them by quality score. \
        Scores jobs based on completeness, clarity, compensation transparency, and other factors. \
        Displays the top N jobs in a formatted table."
    )]
    #[command(after_help = "EXAMPLE:\n  \
        ats-checker rank-jobs --results workspace/search_results.toml --top 10")]
    RankJobs {
        /// Path to job search results file (TOML format)
        #[arg(long)]
        #[arg(help = "Path to TOML file with job search results")]
        #[arg(long_help = "Path to a TOML file containing job search results. \
            This file should have a 'jobs' array with job posting data.")]
        results: String,

        /// Number of top-ranked jobs to display
        #[arg(long, default_value = "20")]
        #[arg(help = "Number of top results to show")]
        #[arg(long_help = "Maximum number of jobs to display in the results. \
            Jobs are ranked by score from highest to lowest.")]
        top: i32,
    },

    /// Search for jobs using `JobSpy` integration
    #[command(name = "job-search")]
    #[command(about = "Search for jobs across multiple job boards")]
    #[command(
        long_about = "Search for jobs using the JobSpy library integration. Supports LinkedIn, Indeed, \
        Glassdoor, Google Jobs, and ZipRecruiter. Results are cached and can be saved for later analysis. \
        Requires Python and the python-jobspy package to be installed."
    )]
    #[command(after_help = "EXAMPLES:\n  \
        # Search for remote Rust jobs on LinkedIn\n  \
        ats-checker job-search --keywords \"rust developer\" --remote --sources linkedin\n\n  \
        # Search multiple sources with location\n  \
        ats-checker job-search --keywords \"software engineer\" --location \"San Francisco\" --sources linkedin,indeed\n\n  \
        # Search with custom output file\n  \
        ats-checker job-search --keywords \"data scientist\" --sources linkedin,glassdoor --output my_jobs.toml")]
    JobSearch {
        /// Search keywords (job title, skills, etc.)
        #[arg(long)]
        #[arg(help = "Keywords to search for (e.g., \"software engineer\", \"rust developer\")")]
        keywords: String,

        /// Location filter
        #[arg(long)]
        #[arg(help = "Location to search in (e.g., \"San Francisco, CA\", \"Remote\")")]
        location: Option<String>,

        /// Job sources to search (comma-separated)
        #[arg(long, value_delimiter = ',', default_value = "linkedin")]
        #[arg(help = "Sources to search: linkedin, indeed, glassdoor, google, ziprecruiter")]
        #[arg(
            long_help = "Comma-separated list of job sources to search. Available sources:\n  \
            - linkedin: LinkedIn Jobs\n  \
            - indeed: Indeed\n  \
            - glassdoor: Glassdoor\n  \
            - google: Google Jobs\n  \
            - ziprecruiter: ZipRecruiter"
        )]
        sources: Vec<String>,

        /// Maximum results per source
        #[arg(long, default_value = "50")]
        #[arg(help = "Maximum number of results to fetch per source")]
        max_results: i32,

        /// Only show remote jobs
        #[arg(long)]
        #[arg(help = "Filter to only remote positions")]
        remote: bool,

        /// Output filename (optional)
        #[arg(long)]
        #[arg(help = "Custom output filename (default: auto-generated)")]
        #[arg(long_help = "Optional custom filename for saving results. \
            If not specified, a filename will be generated based on keywords and timestamp.")]
        output: Option<String>,
    },
}
